---
title: "Seshat"
author: "Achille-Laurent"
date: "15/04/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Partie 1 : Analyse générale toutes époques confondues
## 1. Les données
* Seshat global history databank
* Variables complexité sociale etc
* Renormalisée, populations en log
* Mis sous python pour avoir un meileur index
* Inspiré de l'article


## 3. Analyse de la base normalisée
* base date compter comme différente
```{r}
dfn <- read.csv('socompindexe.csv',sep=',')
# Mettre l'Index en index et retirer SPC1
data <- subset(dfn, select=-c(Index,SPC1))
rownames(data) <- dfn$Index
attach(data)
head(dfn)
str(data)
head(data)
dim(data)
dim(dfn)
```
### 3.1. Vue d'ensemble
* boxplot
```{r}
# Séparer les 2 plots qui sont d'échelle différente
boxplot(subset(data,select = c(PolPop,PolTerr,CapPop,levels,money)))
boxplot(subset(data,select = c(government,infrastr,writing,texts)))
```

### 3.2. ACP
* (2D, Prop Variance)
```{r}
X= scale(data, center=T, scale=T) 

S = cov(X)
acp = eigen(S)
lambda = acp$values
vecteurs_propres = acp$vectors
Inertie = sum(diag(S))
part.inertie = lambda/sum(lambda)
barplot(lambda/sum(lambda),names.arg = 1:length(lambda))
title(main="Explication des différentes composantes")

# Les composantes principales : 
C = X %*% vecteurs_propres #changement de base vers la nouvelle base des composantes principales
dim(C)
# colnames(C) =   paste("comp", 1:4)
plot(C[,1:2],type="p",xlab='PC1',ylab='PC2')
str(C)
# text(C[,1:2])
title(main="Projection sur les 2 premiers axes principaux")
lines(c(min(C[,1]),max(C[,1])),c(0,0))
lines(c(0,0),c(min(C[,2]),max(C[,2])))

barplot(-vecteurs_propres[,1],ylab = 'Contribution',xlab = 'Variables',names.arg = names(data),axes = TRUE)
title(main="Contributions des variables au PC1")

barplot(-vecteurs_propres[,2],ylab = 'Contribution',xlab = 'Variables',names.arg = names(data),axes = TRUE)
title(main="Contributions des variables au PC2")
```

Remarquer que :
* La premiere composante explique tout : interpréter
* On peut remarquer deux clusters sur l'ACP
* Toutes les variables contribuent de la même façon au PC1, interpréter
* Pour le pc2 on observe des nuances d'ordre similaire, voir cercle
```{r}
library(FactoMineR)
pca <- PCA(data, scale.unit = TRUE, ncp = 11, graph = TRUE)
pca$var$cos2
cos2C1 = pca$ind$cos2[,1] + pca$ind$cos2[,2] # tous proches de 1 donc  
length(cos2C1)
length(cos2C1[cos2C1 > 0.8])
plot(pca,choix="ind")    # graphe des individus
plot(pca,choix="var")    # graphe des variables 

plot(pca, cex=pca$ind$cos2, choix="ind")
plot(pca, select="cos2 0.8", choix="ind")
```

### 3.3 k-means et CAH
On a vu sur l'ACP qu'on pouvait distinguer environ deux groupes. On essaie des k-means :
```{r}
kmeans.result = kmeans(data,3)
plot(C[,1:2],type="p",xlab='PC1',ylab='PC2',col = kmeans.result$cluster+3)
kmeans.result = kmeans(data,2)
plot(C[,1:2],type="p",xlab='PC1',ylab='PC2',col = kmeans.result$cluster)
```
Pour k = 3, on a un groupe qui contient les points dispersés du milieu.
Pour savoir quelle classification est la plus pertinente, essayons un CAH :
```{r}
hc <- hclust(dist(data), method="ward.D2")
plot(hc,hang=-1,labels = FALSE)
rect.hclust(hc,k=2,border = 4)
rect.hclust(hc,k=3)
barplot(hc$height[(length(hc$height)-10):(length(hc$height))])
```
On ne peut pas vraiment savoir si c'est deux ou 3 classes qu'on peut garder ... Essayons avec pam
```{r}
library(cluster)
pam.result <- pam(data,2)
plot(pam.result)
pam.result <- pam(data,3)
plot(pam.result)
```
Je ne sais pas trop ce que tout cela signifie.
Peut être du côté de la fonction FAMD ?


Une fois les groupes réunis, il serait intéressant de comprendre ce qui les distingue, les deux dimensions n'y suffisent pas entièrement :
```{r}
k = 3
kmeans.result = kmeans(data,k)
plot(C[,1:2],type="p",xlab='PC1',ylab='PC2',col = kmeans.result$cluster)

data.petit = subset(data,select = c(government,infrastr,writing,texts))
data.grand = subset(data,select = c(PolPop,PolTerr,CapPop,levels,money))
data.grand.all = list()

for(nom in names(data.grand))
{
  for(i in 1:k)
  {
      data.grand.all[[paste(nom,i)]] <- data.grand[kmeans.result$cluster==i,nom]
  }
}
boxplot(data.grand.all,col = rep(c(2:(k+1)),length(data.grand)))

data.petit.all = list()

for(nom in names(data.petit))
{
  for(i in 1:k)
  {
      data.petit.all[[paste(nom,i)]] <- data.petit[kmeans.result$cluster==i,nom]
  }
}
boxplot(data.petit.all,col = rep(c(2:(k+1)),length(data.petit)))

# data.petit.all <- list(data.petit.1$government,data.petit.2$government))
# head(data.petit.all)
```


### 3.4 K-fold
* cross validation

### 3.5 Autres
* tests,lm, beackward forward,
* temps (k means sur évolution PC1)

## 2. Analyse de la base originale
* random forest


## Partie 2 : Analyse à différentes époques
```{r}
dfn <- read.csv('axial.csv',sep=',')
dfn_melange <- read.csv('socompindexe.csv',sep=',')
colnames(dfn)
length(colnames(dfn))
dfn = subset(dfn, select=-c(PolID, SPC1, MG_corr, NGA))
pays_et_date = dfn_melange[[1]]
dfn[[1]] = pays_et_date
rownames(dfn) <- dfn$NGA
attach(dfn)
head(dfn)
```
* On répartit les données sur 3 époques, un jeu de données de taille environ 288 pour chaque époque
# t = table(dfn$Time)
# print(t)
# cumsum(t)
# head(dfn)
# t2 = table(dfn$NGA)
# names(t2)   
# print(t2[t2<9])
# length(t2[t2<9])
```{r}
df1 = subset(dfn, -9600 <= dfn$Time & dfn$Time <= -2100) #len = 288
df2 = subset(dfn, -2000 <= dfn$Time & dfn$Time <= 400) #len = 296
df3 = subset(dfn, 500 <= dfn$Time & dfn$Time <= 1900) #len = 280
df1 = subset(df1, select=-c(Time))
df2 = subset(df2, select=-c(Time))
df3 = subset(df3, select=-c(Time))
```

### 3.1. Vue d'ensemble
* boxplot
```{r}
# Séparer les 2 plots qui sont d'échelle différente
boxplot(main="df1", subset(df1,select = c(PolPop,PolTerr,CapPop,levels,money)))
boxplot(main="df1", subset(df1,select = c(government,infrastr,writing,texts)))
boxplot(main="df2", subset(df2,select = c(PolPop,PolTerr,CapPop,levels,money)))
boxplot(main="df2", subset(df2,select = c(government,infrastr,writing,texts)))
boxplot(main="df3", subset(df3,select = c(PolPop,PolTerr,CapPop,levels,money)))
boxplot(main="df3", subset(df3,select = c(government,infrastr,writing,texts)))
```

### 3.2. ACP
* (2D, Prop Variance)
```{r}
typeof(df1)
X1= scale(df1, center=T, scale=T)
X2= scale(df2, center=T, scale=T)
X3= scale(df3, center=T, scale=T)
S1 = cov(X1)
S2 = cov(X2)
S3 = cov(X3)
acp1 = eigen(S1)
acp2 = eigen(S2)
acp3 = eigen(S3)
lambda1 = acp1$values
lambda2 = acp2$values
lambda3 = acp3$values
vecteurs_propres_df1 = acp2$vectors
vecteurs_propres_df2 = acp2$vectors
vecteurs_propres_df3 = acp3$vectors
Inertie1 = sum(diag(S1))
Inertie2 = sum(diag(S2))
Inertie3 = sum(diag(S3))
part.inertie = lambda1/sum(lambda1)
part.inertie = lambda2/sum(lambda2)
part.inertie = lambda3/sum(lambda3)

## Graphique : explication des différentes composantes
barplot(lambda1/sum(lambda1),names.arg = 1:length(lambda2))
title(main="Explication des différentes composantes df1")
barplot(lambda2/sum(lambda2),names.arg = 1:length(lambda2))
title(main="Explication des différentes composantes df2")
barplot(lambda3/sum(lambda3),names.arg = 1:length(lambda3))
title(main="Explication des différentes composantes df3")

# Les composantes principales : 
C1 = X1 %*% vecteurs_propres_df1 #changement de base vers la nouvelle base des composantes principales
C2 = X2 %*% vecteurs_propres_df2
C3 = X3 %*% vecteurs_propres_df3

##Graphique : projection sur les 2 premiers axes principaux
# colnames(C) =   paste("comp", 1:4)
plot(C1[,1:2],type="p",xlab='PC1',ylab='PC2')
lines(c(min(C1[,1]),max(C1[,1])),c(0,0))
lines(c(0,0),c(min(C1[,2]),max(C1[,2])))
title(main="Projection sur les 2 premiers axes principaux df1")

plot(C2[,1:2],type="p",xlab='PC1',ylab='PC2')
lines(c(min(C2[,1]),max(C2[,1])),c(0,0))
lines(c(0,0),c(min(C2[,2]),max(C2[,2])))
title(main="Projection sur les 2 premiers axes principaux df2")

plot(C3[,1:2],type="p",xlab='PC1',ylab='PC2')
lines(c(min(C3[,1]),max(C3[,1])),c(0,0))
lines(c(0,0),c(min(C3[,2]),max(C3[,2])))
title(main="Projection sur les 2 premiers axes principaux df3")

# str(C)
# text(C[,1:2])

## Graphique : contributions des variables au PC1
barplot(-vecteurs_propres_df1[,1],ylab = 'Contribution',xlab = 'Variables',names.arg = names(df1),axes = TRUE)
title(main="Contributions des variables au PC1 (df1)")
barplot(-vecteurs_propres_df2[,1],ylab = 'Contribution',xlab = 'Variables',names.arg = names(df2),axes = TRUE)
title(main="Contributions des variables au PC1 (df2)")
barplot(-vecteurs_propres_df3[,1],ylab = 'Contribution',xlab = 'Variables',names.arg = names(df3),axes = TRUE)
title(main="Contributions des variables au PC1 (df3)")

## Graphique : contributions des variables au PC2
barplot(-vecteurs_propres_df1[,2],ylab = 'Contribution',xlab = 'Variables',names.arg = names(df1),axes = TRUE)
title(main="Contributions des variables au PC2 (df1)")
barplot(-vecteurs_propres_df2[,2],ylab = 'Contribution',xlab = 'Variables',names.arg = names(df2),axes = TRUE)
title(main="Contributions des variables au PC2 (df2)")
barplot(-vecteurs_propres_df3[,2],ylab = 'Contribution',xlab = 'Variables',names.arg = names(df3),axes = TRUE)
title(main="Contributions des variables au PC2 (df3)")
```

Remarquer que :
* La premiere composante explique tout : interpréter
* On peut remarquer deux clusters sur l'ACP pour df2 et df3, et vaguement pour df1. 
* Toutes les variables contribuent de la même façon au PC1, interpréter
* Pour le pc2 on observe des nuances d'ordre similaire, voir cercle
```{r}
library(FactoMineR)
pca1 <- PCA(df1, scale.unit = TRUE, ncp = 11, graph = TRUE)
pca2 <- PCA(df2, scale.unit = TRUE, ncp = 11, graph = TRUE)
pca3 <- PCA(df3, scale.unit = TRUE, ncp = 11, graph = TRUE)

pca1$var$cos2
pca2$var$cos2
pca3$var$cos2
cos2C1_df1 = pca1$ind$cos2[,1] + pca1$ind$cos2[,2] # tous proches de 1 donc  
cos2C1_df2 = pca2$ind$cos2[,1] + pca2$ind$cos2[,2] # tous proches de 1 donc  
cos2C1_df3 = pca3$ind$cos2[,1] + pca3$ind$cos2[,2] # tous proches de 1 donc  
length(cos2C1_df1[cos2C1_df1 > 0.8])
length(cos2C1_df1[cos2C1_df2 > 0.8])
length(cos2C1_df1[cos2C1_df3 > 0.8])

plot(pca1,choix="ind")    # graphe des individus
plot(pca1,choix="var")    # graphe des variables 

plot(pca2,choix="ind")    # graphe des individus
plot(pca2,choix="var")    # graphe des variables 

plot(pca3,choix="ind")    # graphe des individus
plot(pca3,choix="var")    # graphe des variables 

plot(pca1, cex=pca1$ind$cos2, choix="ind")
plot(pca2, cex=pca2$ind$cos2, choix="ind")
plot(pca3, cex=pca3$ind$cos2, choix="ind")

plot(pca1, select="cos2 0.8", choix="ind")
plot(pca2, select="cos2 0.8", choix="ind")
plot(pca3, select="cos2 0.8", choix="ind")
```

### 3.3 k-means et CAH
On a vu sur l'ACP qu'on pouvait distinguer environ deux groupes. On essaie des k-means :
```{r}
kmeans.result = kmeans(df1,3)
plot(C1[,1:2],type="p",xlab='PC1',ylab='PC2',col = kmeans.result$cluster+3, main="df1, k = 3")
kmeans.result = kmeans(df1,2)
plot(C1[,1:2],type="p",xlab='PC1',ylab='PC2',col = kmeans.result$cluster, main="df1, k = 2")

kmeans.result = kmeans(df2,2)
plot(C2[,1:2],type="p",xlab='PC1',ylab='PC2',col = kmeans.result$cluster, main="df2, k = 2")

kmeans.result = kmeans(df3,3)
plot(C3[,1:2],type="p",xlab='PC1',ylab='PC2',col = kmeans.result$cluster+3, main="df3, k = 3")
kmeans.result = kmeans(df3,2)
plot(C3[,1:2],type="p",xlab='PC1',ylab='PC2',col = kmeans.result$cluster, main="df3, k = 2")
```
Pour k = 3, on a un groupe qui contient les points dispersés du milieu.
Pour savoir quelle classification est la plus pertinente, essayons un CAH :
```{r}
hc1 <- hclust(dist(df1), method="ward.D2")
plot(hc1,hang=-1,labels = FALSE, main="df1")
rect.hclust(hc1,k=2,border = 4)
rect.hclust(hc1,k=3)
barplot(hc1$height[(length(hc1$height)-10):(length(hc1$height))], main="df1")

hc2 <- hclust(dist(df2), method="ward.D2")
plot(hc2,hang=-1,labels = FALSE, main="df2")
rect.hclust(hc2,k=2,border = 4)
rect.hclust(hc2,k=3)
barplot(hc2$height[(length(hc2$height)-10):(length(hc2$height))], main="df2")

hc3 <- hclust(dist(df3), method="ward.D2")
plot(hc3,hang=-1,labels = FALSE, main="df3")
rect.hclust(hc3,k=2,border = 4)
rect.hclust(hc3,k=3)
barplot(hc3$height[(length(hc3$height)-10):(length(hc3$height))], main="df3")
```
Il semble qu'il faille garder à chaque fois 2 classes.
```{r}
library(cluster)
pam.result <- pam(df1,2)
plot(pam.result, main="df1, k = 2")
pam.result <- pam(df1,3)
plot(pam.result, main="df1, k = 3")

pam.result <- pam(df2,2)
plot(pam.result, main="df2")
pam.result <- pam(df2,3)
plot(pam.result, main="df2")

pam.result <- pam(df3,2)
plot(pam.result, main="df3")
pam.result <- pam(df3,3)
plot(pam.result, main="df3")

```
Je ne sais pas trop ce que tout cela signifie.
Peut être du côté de la fonction FAMD ?


Une fois les groupes réunis, il serait intéressant de comprendre ce qui les distingue, les deux dimensions n'y suffisent pas entièrement :
```{r}
k = 2
kmeans.result = kmeans(df1,2)
plot(C1[,1:2],type="p",xlab='PC1',ylab='PC2',col = kmeans.result$cluster, main = "df1") #affiche kmeans en acp

df1.petit = subset(df1,select = c(government,infrastr,writing,texts))
df1.grand = subset(df1,select = c(PolPop,PolTerr,CapPop,levels,money))
df1.grand.all = list()

for(nom in names(df1.grand))
{
  for(i in 1:k)
  {
      df1.grand.all[[paste(nom,i)]] <- df1.grand[kmeans.result$cluster==i,nom]
  }
}
boxplot(df1.grand.all,col = rep(c(2:(k+1)),length(df1.grand)), main = "df1")

df1.petit.all = list()

for(nom in names(df1.petit))
{
  for(i in 1:k)
  {
      df1.petit.all[[paste(nom,i)]] <- df1.petit[kmeans.result$cluster==i,nom]
  }
}
boxplot(df1.petit.all,col = rep(c(2:(k+1)),length(df1.petit)), main = "df1")

# data.petit.all <- list(data.petit.1$government,data.petit.2$government))
# head(data.petit.all)
```

```{r}
k = 2
kmeans.result = kmeans(df2,2)
plot(C2[,1:2],type="p",xlab='PC1',ylab='PC2',col = kmeans.result$cluster, main = "df2") #affiche kmeans en acp

df2.petit = subset(df2,select = c(government,infrastr,writing,texts))
df2.grand = subset(df2,select = c(PolPop,PolTerr,CapPop,levels,money))
df2.grand.all = list()

for(nom in names(df2.grand))
{
  for(i in 1:k)
  {
      df2.grand.all[[paste(nom,i)]] <- df2.grand[kmeans.result$cluster==i,nom]
  }
}
boxplot(df2.grand.all,col = rep(c(2:(k+1)),length(df2.grand)), main = "df2")

df2.petit.all = list()

for(nom in names(df2.petit))
{
  for(i in 1:k)
  {
      df2.petit.all[[paste(nom,i)]] <- df2.petit[kmeans.result$cluster==i,nom]
  }
}
boxplot(df2.petit.all,col = rep(c(2:(k+1)),length(df2.petit)), main = "df2")

# data.petit.all <- list(data.petit.1$government,data.petit.2$government))
# head(data.petit.all)
```

```{r}
k = 2
kmeans.result = kmeans(df3,2)
plot(C3[,1:2],type="p",xlab='PC1',ylab='PC2',col = kmeans.result$cluster, main = "df3") #affiche kmeans en acp

df3.petit = subset(df3,select = c(government,infrastr,writing,texts))
df3.grand = subset(df3,select = c(PolPop,PolTerr,CapPop,levels,money))
df3.grand.all = list()

for(nom in names(df3.grand))
{
  for(i in 1:k)
  {
      df3.grand.all[[paste(nom,i)]] <- df3.grand[kmeans.result$cluster==i,nom]
  }
}
boxplot(df3.grand.all,col = rep(c(2:(k+1)),length(df3.grand)), main = "df3")

df3.petit.all = list()

for(nom in names(df3.petit))
{
  for(i in 1:k)
  {
      df3.petit.all[[paste(nom,i)]] <- df3.petit[kmeans.result$cluster==i,nom]
  }
}
boxplot(df3.petit.all,col = rep(c(2:(k+1)),length(df3.petit)), main = "df3")

# data.petit.all <- list(data.petit.1$government,data.petit.2$government))
# head(data.petit.all)
```
